Javascript Design Patterns

What is a Pattern?

A pattern is a reusable solution that can be applied to commonly occurring problems in software design - in our case - in writing JavaScript web applications. Another way of looking at patterns are as templates for how we solve problems -

Patterns are proven solutions: They provide solid approaches to solving issues in software development using proven techniques that reflect the experience and insights the developers that helped define them bring to the pattern.

Patterns can be easily reused: A pattern usually reflects an out of the box solution that can be adapted to suit our own needs. This feature makes them quite robust.

Patterns can be expressive: When we look at a pattern thereâ€™s generally a set structure and vocabulary to the solution presented that can help express rather large solutions quite elegantly.
Reusing patterns assists in preventing minor issues that can cause major problems in the application development process. What this means is when code is built on proven patterns, we can afford to spend less time worrying about the structure of our code and more time focusing on the quality of our overall solution. This is because patterns can encourage us to code in a more structured and organized fashion avoiding the need to refactor it for cleanliness purposes in the future.
Patterns can provide generalized solutions which are documented in a fashion that doesn't require them to be tied to a specific problem. This generalized approach means that regardless of the application (and in many cases the programming language) we are working with, design patterns can be applied to improve the structure of our code.
Certain patterns can actually decrease the overall file-size footprint of our code by avoiding repetition. By encouraging developers to look more closely at their solutions for areas where instant reductions in repetition can be made, e.g. reducing the number of functions performing similar processes in favor of a single generalized function, the overall size of our codebase can be decreased. This is also known as making code more DRY.
Patterns add to a developer's vocabulary, which makes communication faster.
Patterns that are frequently used can be improved over time by harnessing the collective experiences other developers using those patterns contribute back to the design pattern community. In some cases this leads to the creation of entirely new design patterns whilst in others it can lead to the provision of improved guidelines on how specific patterns can be best used. This can ensure that pattern-based solutions continue to become more robust than ad-hoc solutions may be.


One of the additional requirements for a pattern to be valid is that they display some recurring phenomenon. This is often something that can be qualified in at least three key areas, referred to as the rule of three. To show recurrence using this rule, one must demonstrate:

Fitness of purpose - how is the pattern considered successful?
Usefulness - why is the pattern considered successful?
Applicability - is the design worthy of being a pattern because it has wider applicability? If so, this needs to be explained. When reviewing or defining a pattern, it is important to keep the above in mind.

A pattern is initially presented in the form of a rule that establishes a relationship between:

A context
A system of forces that arises in that context and
A configuration that allows these forces to resolve themselves in context


  Creational	  Based on the concept of creating an object.
    Class
      Factory Method	This makes an instance of several derived classes based on interfaced data or events.
    Object
      Abstract Factory	Creates an instance of several families of classes without detailing concrete classes.
      Builder	Separates object construction from its representation, always creates the same type of object.
      Prototype	A fully initialized instance used for copying or cloning.
      Singleton	A class with only a single instance with global access points.
 	 	 	 	 	 	 	 
  Structural	  Based on the idea of building blocks of objects.
    Class
      Adapter	Match interfaces of different classes therefore classes can work together despite incompatible interfaces.
    Object
      Adapter	Match interfaces of different classes therefore classes can work together despite incompatible interfaces.
      Bridge	Separates an object's interface from its implementation so the two can vary independently.
      Composite	A structure of simple and composite objects which makes the total object more than just the sum of its parts.
      Decorator	Dynamically add alternate processing to objects.
      Facade	A single class that hides the complexity of an entire subsystem.
      Flyweight	A fine-grained instance used for efficient sharing of information that is contained elsewhere.
      Proxy	A place holder object representing the true object.
 
  Behavioral	  Based on the way objects play and work together.
    Class
      Interpreter	A way to include language elements in an application to match the grammar of the intended language.
      Template 
       Method	Creates the shell of an algorithm in a method, then defer the exact steps to a subclass.
    Object
      Chain of 
      Responsibility	A way of passing a request between a chain of objects to find the object that can handle the request.
      Command	Encapsulate a command request as an object to enable, logging and/or queuing of requests, and provides error-handling for unhandled requests.
      Iterator	Sequentially access the elements of a collection without knowing the inner workings of the collection.
      Mediator	Defines simplified communication between classes to prevent a group of classes from referring explicitly to each other.
      Memento	Capture an object's internal state to be able to restore it later.
      Observer	A way of notifying change to a number of classes to ensure consistency between the classes.
      State	Alter an object's behavior when its state changes.
      Strategy	Encapsulates an algorithm inside a class separating the selection from the implementation.
      Visitor	Adds a new operation to a class without changing the class.
 

 Basic Constructors

As we saw earlier, JavaScript doesn't support the concept of classes but it does support special constructor functions that work with objects. By simply prefixing a call to a constructor function with the keyword "new", we can tell JavaScript we would like the function to behave like a constructor and instantiate a new object with the members defined by that function.